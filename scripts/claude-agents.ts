// Claude Agent Management System - Browser Compatible
// Frontend client for managing pool of Claude Code agents

export interface ClaudeAgent {
  id: string;
  specialization: 'frontend' | 'backend' | 'database' | 'testing' | 'devops';
  status: 'idle' | 'working' | 'blocked' | 'error';
  currentTask?: any;
  lastActivity?: Date;
}

export interface CodeArtifact {
  path: string;
  content: string;
  type: 'file' | 'directory' | 'command';
  description?: string;
}

export interface RemoteAgentInfo {
  id: string;
  capabilities: string[];
  status: 'connected' | 'busy' | 'error';
  lastHeartbeat: Date;
  taskCount: number;
}

class ClaudeAgentPool {
  private agents: Map<string, ClaudeAgent> = new Map();
  private remoteAgents: RemoteAgentInfo[] = [];

  constructor() {
    this.initializeLocalAgents();
    this.startPeriodicUpdates();
  }

  private initializeLocalAgents() {
    // Create simulated local agents for demo
    const agentSpecs = [
      { id: 'agent_frontend_001', specialization: 'frontend' as const },
      { id: 'agent_backend_001', specialization: 'backend' as const },
      { id: 'agent_database_001', specialization: 'database' as const },
      { id: 'agent_testing_001', specialization: 'testing' as const },
      { id: 'agent_devops_001', specialization: 'devops' as const },
    ];

    agentSpecs.forEach(spec => {
      this.agents.set(spec.id, {
        ...spec,
        status: 'idle',
        lastActivity: new Date()
      });
    });
  }

  private startPeriodicUpdates() {
    // Update remote agent status every 30 seconds
    setInterval(() => {
      this.updateRemoteAgentStatus();
    }, 30000);
  }

  private async updateRemoteAgentStatus() {
    try {
      const response = await fetch('/api/remote-agents/status');
      if (response.ok) {
        const data = await response.json();
        if (data.agents) {
          this.remoteAgents = data.agents.map((agent: any) => ({
            id: agent.id,
            capabilities: agent.capabilities || [],
            status: agent.status || 'connected',
            lastHeartbeat: new Date(agent.lastHeartbeat || Date.now()),
            taskCount: agent.taskCount || 0
          }));
        }
      }
    } catch (error) {
      console.log('Remote agent status update failed:', error);
    }
  }

  // Execute task using API calls to backend
  async executeWithClaude(task: any): Promise<CodeArtifact[]> {
    const agent = await this.assignAgent(task);
    if (!agent) {
      // Try remote agents via API
      return this.executeWithRemoteAgent(task);
    }

    try {
      // Update agent status
      agent.status = 'working';
      agent.currentTask = task;
      this.agents.set(agent.id, agent);

      // For demo: simulate code generation
      const artifacts = await this.simulateCodeGeneration(task);

      // Mark agent as idle
      agent.status = 'idle';
      agent.currentTask = undefined;
      agent.lastActivity = new Date();
      this.agents.set(agent.id, agent);

      return artifacts;
    } catch (error) {
      agent.status = 'error';
      this.agents.set(agent.id, agent);
      throw error;
    }
  }

  private async executeWithRemoteAgent(task: any): Promise<CodeArtifact[]> {
    try {
      // Mock remote execution for static deployment
      await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate processing time
      
      return this.simulateCodeGeneration(task);
    } catch (error) {
      // Fallback to local simulation
      return this.simulateCodeGeneration(task);
    }
  }

  private async simulateCodeGeneration(task: any): Promise<CodeArtifact[]> {
    // Simulate work delay
    await new Promise(resolve => setTimeout(resolve, 2000));

    const artifacts: CodeArtifact[] = [];

    // Generate simulated artifacts based on task type
    if (task.description?.toLowerCase().includes('component')) {
      artifacts.push({
        path: 'src/components/NewComponent.tsx',
        content: `export const NewComponent = () => {
  return (
    <div className="p-4">
      <h2>Generated Component</h2>
      <p>This component was generated for: ${task.description}</p>
    </div>
  );
};`,
        type: 'file',
        description: 'React component generated by Claude'
      });
    }

    if (task.description?.toLowerCase().includes('api')) {
      artifacts.push({
        path: 'src/api/newEndpoint.ts',
        content: `export async function handler(req: any, res: any) {
  // Generated API endpoint for: ${task.description}
  res.json({ 
    message: 'API endpoint generated by Claude',
    timestamp: new Date().toISOString()
  });
}`,
        type: 'file',
        description: 'API endpoint generated by Claude'
      });
    }

    return artifacts;
  }

  private async assignAgent(task: any): Promise<ClaudeAgent | null> {
    // Find idle agent with matching specialization
    const agents = Array.from(this.agents.values());
    const idleAgents = agents.filter(a => a.status === 'idle');

    if (idleAgents.length === 0) return null;

    // Try to match specialization
    const taskType = task.type?.toLowerCase();
    const preferredAgent = idleAgents.find(agent => 
      taskType?.includes(agent.specialization.toLowerCase())
    );

    return preferredAgent || idleAgents[0];
  }

  // Get current agent status including remote agents
  getRemoteAgentStatus(): (ClaudeAgent & { isRemote?: boolean })[] {
    const localAgents = Array.from(this.agents.values()).map(agent => ({
      ...agent,
      isRemote: false
    }));

    const remoteAgentsAsLocal = this.remoteAgents.map(agent => ({
      id: agent.id,
      specialization: 'backend' as const,
      status: agent.status === 'connected' ? 'idle' as const : 
              agent.status === 'busy' ? 'working' as const : 'error' as const,
      currentTask: undefined,
      lastActivity: agent.lastHeartbeat,
      isRemote: true
    }));

    return [...localAgents, ...remoteAgentsAsLocal];
  }

  // Get detailed stats for monitoring
  getStats() {
    const localAgents = Array.from(this.agents.values());
    return {
      local: {
        total: localAgents.length,
        idle: localAgents.filter(a => a.status === 'idle').length,
        working: localAgents.filter(a => a.status === 'working').length,
        error: localAgents.filter(a => a.status === 'error').length
      },
      remote: {
        total: this.remoteAgents.length,
        connected: this.remoteAgents.filter(a => a.status === 'connected').length,
        busy: this.remoteAgents.filter(a => a.status === 'busy').length,
        error: this.remoteAgents.filter(a => a.status === 'error').length
      }
    };
  }
}

// Export singleton instance
export const claudeAgentPool = new ClaudeAgentPool();